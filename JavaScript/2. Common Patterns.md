# Common Patterns

## Creating Views

Views encapsulate the logic of a DOM element and it's children. Views are usually constructor functions that take an element and a model.

The following is a pattern that is often used with Views.

```js
function View(el, model, options) {
  this.el = el;
  this.model = model;
  this.options = options || {};
  this.reactive = reactive(el, model, this);
}
```

## Creating Models

Models are just objects that emit events when properties change. The simplest solution to this is the Observable component.

```js
var Model = require('observable');
var person = new Model();
person.set('hair', 'brunette');
```

These models can be used in views or with Reactive. These are handy whenever you need to watch for data changes. Generally a view should only ever have a single model though.

## Using Reactive

Reactive is useful for pushing a lot of the common logic we write in views into bindings. These bindings can be reused across views. The other benefit is that we don't need to wire the DOM up to our views.

## Using constructor functions

Constructor functions should be used in most situations. They are generally easier to test as well.

```js
function MyComponent() {

}
MyComponent.prototype.foo = function(){};
```

We also avoid using libraries to abstract this pattern. We could use libraries to automatically add methods to the prototypes when given an object, but in the spirit of keeping things simple we just use plain old functions.

## Boot Components

Often the logic associated with initializing a component shouldn't be part of the component itself. For example, a dialog component might expose a `Dialog` object that makes it easy to create dialogs by calling `new Dialog`. 

You might like to make dialogs appear when click a link, then using that links `href` attribute to load a dialog. This means we need to listen for clicks on certain anchors and create new dialogs. This code doesn't belong in the dialog itself.

To get around this, we create "boot" components that wrap up this functionality. In the example above, we would create a "boot-dialog" component that requires the `dialog` and then hooks up the DOM.

This means we can now reuse that dialog in many different ways without restricting it to a single pattern.

Some examples:

* [boot-classes](https://github.com/nib-components/boot-classes)
* [boot-affix](https://github.com/nib-components/boot-affix)
* [boot-accordion](https://github.com/nib-components/boot-accordion)
* [boot-dialog](https://github.com/nib-components/boot-dialog)

## Avoid Inheritance

In JavaScript people often try to replicate languages with class constructs. They do this by creating constructor functions and then extending them to create child classes. 

This is a bad thing to do with JavaScript as it quickly complicates the code and makes it harder to test. It's also not necessary as JavaScript is a dynamic language.

Instead, try using composition instead of inheritance. It makes testing easy. People often then try to do dependency injection with this pattern. This should be avoided as well. Again, it's not needed. You can easily modify and stub the properties of an object in the tests.

For example, **don't do this**

```js
function View(el){
  this.el = el;
}

function Form(){
  View.apply(this, arguments);
}

Form.prototype = Object.create(View.prototype);
```

Instead, do this:

```js
function View(el){
  this.el = el;
  this.form = new Form();
}

function Form() {
  this.errors = [];
}
```

If you're having trouble testing like this, just move it out onto the prototype:

```js
function View(el){
  this.el = el;
  this.form = new exports.Form();
}

exports.Form = Form;
```

Then you can just change the `exports` object in the tests. 

## Promises

A promise is an incredibly handy object generally used for AJAX requests, but intended for all asychronous operations. When a opretation is constructed and started, the consumer may specify functions to be invoked on progress/completion of the operation. An example of an AJAX client that uses the promise library [q](https://github.com/kriskowal/q):

```js
var AwesomeClient = require('someAwesomeClient');

function MyClass(){
  this.client = new AwesomeClient();
  
  //...
  
  this.client.doGetRequest('http://some.url/').then(function callback(data){
    //... do something with the GET data
  });
  
}

```

The method `#doGetRequest` returns us a promise object containing, amongst other things, a `#then` function which we can specify a callback to be invoked upon completion of the request. The constructor of the promise object, in this case the `someAwesomeClient`, is responsible for specifying what arguments get passed to callbacks, which is simply a `data` object for all `#doGetRequest` promises.

For more information about promises and how to implement them, see [the q library](https://github.com/kriskowal/q) and related docs.

## Bind, Apply and Call on functions

### `#bind`

Calling `#bind` on a function returns a clone of the function (for lack of a better term) that, when invoked, will be invoked with the arguments passed to `#bind`. The first argument of the `#bind` function is the context or `this` of the function, and all proceeding arguments to `#bind` will be passed to the function. For example:

```js

var myFunc = function(a){
  console.log(this);
  console.log(a);
}

myFunc('foo');
>>> undefined
>>> foo

var binded = myFunc.bind('foo', 'bar');
binded();
>>> foo
>>> bar

```

`#bind` is generally used for the context of callbacks to DOM events that require the context of the class, not the context of the event, e.g:

```js

el.addEventListener('click', this.myCallback.bind(this));

//...

MyClass.prototype.myCallback = function(event){
  this.myValue = event.value;
};

```

### `#apply`

Similar to `#bind`, `#apply` will invoke the specified function with the context and arguments passed to `#apply`, e.g:

```js
var myFunc = function(a){
  console.log(this);
  console.log(a);
}

myFunc.apply('foo', 'bar');
>>> foo
>>> bar
```
